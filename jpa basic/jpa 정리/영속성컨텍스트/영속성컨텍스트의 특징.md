# 영속성 컨텍스트의 특징(이점)

- 1차 캐시(어플리케이션과 데이터베이스의 중간에 있는 중계기역할이므로 캐시가가능)
- 동일성 보장(자바 컬렉션처럼 한 트랜잭션 내의 동일한 엔티티에 대해서 동일성보장.)
- 트랜잭션을 지원하는 쓰기지연(커밋이 되야 그때서야 INSERT쿼리가 DB로 나가는 쓰기지연 - 영속성 컨텍스트 내의 쓰기지연 전용 SQL저장소 떄문에 가능)
- 변경감지(영속성 컨텍스트의 1차 캐싱의 스냅샷과 변경된 엔티티를 비교해서 변경되면 쓰기지면 SQL저장소에 UPDATE쿼리를 넣었다가 커밋될때 업데이트 쿼리가나감, 즉, 영속성 컨텍스트의 1차캐싱으로 엔티티가 관리되고 있기에 setXxx로 데이터변경하면 알아서 DB로 업데이트 쿼리가 나감)
- 지연로딩

# 엔티티 조회

- 영속성 컨텍스트(PersistenceContext)내의 1차캐싱을 이용한다.
- `entityManager.persist`를 하면 영속관계가 되고 엔티티는 영속성 컨텍스트에서 관리된다.
- 1차캐싱에 Key는 PK, value는 엔티티로 저장이되고 동시에 쓰기지연 SQL저장소에 INSERT쿼리가저장된다.

```java
em.persist(new Member(8L, "memberA"));

tx.commit();
```

- 트랜잭션 commit이 되면 쓰기지연 SQL저장소의 쿼리가 DB로 쿼리가 나간다.

이상태에서 `em.find`로 엔티티 매니져를 통해서 영속성 컨텍스트의 엔티티를 조회하면 1차적으로 1차캐싱에서 엔티티를 찾는다. 없으면 2차적으로 DB에서 SELECT쿼리를 날려서 1차캐싱에 넣어두고 1차캐싱에서 데이터를 꺼낸다. 즉, 이렇게 영속성컨텍스트는 **1차 캐싱**을하는 특징이 있다.

```java
em.persist(new Member(8L, "memberA"));

Member findMember = em.find(Member.class, 8L);

tx.commit();
```

- 쿼리가 SELECT는 안나가고 INSERT만 나가는것을 볼수가있다. 이유는 `em.persist`로 영속성컨텍스트에 엔티티를 저장할때, 영속성 컨텍스트 내의 1차캐싱에 해당 엔티티가 저장이되고 `em.find()`를 할때 1차캐싱에서 엔티티를 꺼내오므로 DB에 SELECT쿼리가 나가지 않는것이다.
- 만약 1차캐싱에 없는 새로운 엔티티를 꺼내려하면 SELECT쿼리가 나간다. 아래 코드처럼.

```java
            em.persist(new Member(8L, "memberA"));

            Member findMember = em.find(Member.class, 8L);
            Member findMember2 = em.find(Member.class, 20L);


            tx.commit();
```

- 그럼 같은 엔티티를 두번 조회하면어떻게될까?

```java
            em.find(Member.class, 8L);
            em.find(Member.class, 8L);
```

- 첫번째 조회때 영속성 컨텍스트 내의 1차 캐싱을 뒤지는데 없으니 DB에서 SELECT쿼리를 날려서 1차캐싱에 저장해놓는다.
- 두번째 조회떄는 1차캐싱에 해당 엔티티가 존재하닌까 SELECT쿼리로 데이터에 접근할 필요없이 바로 1차캐싱에서 엔티티 꺼내서 조회한다.
- 즉 SELECT쿼리는 한번나간다.

> 영속성 컨텍스트 내의 1차캐싱으로 하나의 트랜잭션내에서 DB에 접근하는 쿼리를 줄임으로 아주 미미한 효과가 존재한다.

# 영속성 컨텍스트의 엔티티의 동일성 보장

- 자바 컬렉션에서 같은 아이디의 객체를 두번꺼내면 두 객체는 당연히 ==비교로 같은 주소를 갖는다.

```java
            List<String> list = new ArrayList<>();
            list.add("HELLO");

            String str1 = list.get(0);
            String str2 = list.get(0);

            System.out.println("result = " + (str1 == str2)); // true
```

- 영속성컨텍스트에서 관리되는 엔티티는 1차캐싱되어있기 떄문에 자바 컬렉션처럼 동일한 엔티티에대해서 동일성을 보장한다.

```java
            Member findMember1 = em.find(Member.class, 8L);
            Member findMember2 = em.find(Member.class, 8L);

            System.out.println("result = " + (findMember1 == findMember2)); // result

            tx.commit();
```

- 이러한 이유는 영속성 컨텍스트에서 1차캐싱에 엔티티가 저장되어있기때문이다. 좀더 구체적으로는 첫번째 pk가 8인 엔티티를 조회하면 1차캐싱에 없기에 DB에서 SELECT쿼리날려서 1차캐시에 저장해놓고 두번째 조회(`em.find`)에서는 1차캐싱에 해당 pk의 엔티티가 존재하므로 바로꺼내므로 두 엔티티는 동일하다, 마치 자바컬렉션과 유사하다.

# 엔티티 등록 - 트랜잭션 커밋될때 쓰기 지연의 기능일 지원

- DB에 데이터를 두개 INSERT하고싶다.
- 엔티티 매니져를 이용하면 영속성 컨텍스트를 이용할것이고, em.persist를 하면 1차캐싱과 영속성 컨텍스트내의 쓰기지연 SQL저장소에 해당 쿼리를 저장해놓는다. 그리고 트랜잭션 커밋될때 쓰기지연 SQL저장소에 있는 녀석들을 한번에 DB에 쿼리를 보낸다.

```java

            em.persist(new Member(44L, "ma"));
            em.persist(new Member(45L, "mb"));

            System.out.println("<<<<<<<<<<<<<<<<<<<<<<<<<<");

            tx.commit(); // 트랜잭션 - 커밋(안되면 롤백) //
            System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>");
```

- 분명 "<<<<<<<<<..."의 출력이 나기전에 INSER쿼리가 나가야 정상인데 그게아니라 트랜잭션 커밋될때 영속성 컨텍스트내의 지연쓰기 저장소에있는 쿼리가 DB로 나가게된다.

# 엔티티 수정 - 변경감지 (Dirty Checking)

- DB에서 데이터 업데이트할때는 update쿼리를 날려야한다.
- jpa를 사용하면 뭔가 특정한 update관련 쿼리를 날리는게 아니라 객체를 수정하면 DB의 데이터가 수정이된다.
- 이 과정을 코드로 생각해보자

```java
            Member findMember = em.find(Member.class, 1L);
            findMember.setName("userAAAAAAAAAA");

            tx.commit(); // 트랜잭션 - 커밋(안되면 롤백) //
```

- 먼저 PK가 1인 데이터를 조회하기위해 엔티티 매니져를 통해서 영속성 컨텍스트에 접근한다.
- 1차캐싱에 데이터가 당연히없으므로 일단 SELECT로 데이터를 뽑아와서 1차캐싱에 넣어둔다. 이떄 최초 영속성컨텍스트에 영속된 엔티티에 대해서 스냅샷을 찍어서 같이 1차캐싱에 넣어둔다.(1차 캐싱은 영속성 컨텍스트 내에서 관리된다.)
- 여기서!!!!!!!!!!!!!!!!!!!!!! 해당 엔티티에대한 변경이일어나면 스냅샷과 비교해서.. 어? 변경됐네 라는걸 깨닫고 SQL 쓰기지연 저장소(이것 또한 영속성 컨텍스트 내에서 관리됨) UPDATE쿼리를 저장하고있따.
- 트랜잭션 커밋될때 UPDATE쿼리가 나가게된다.

> jpa는 엔티티의 변경을 감지하여 알아서 UPDATE쿼리를 날린다는것이 중요하다. 개발자가 무언가 UPDATE관련 쿼리를 날릴필요가없다. 이는 영속성 컨텍스트에서 엔티티가 관리가 되어지고있기 때문이다.

# 엔티티 삭제

- jpa가 변경을 감지하는 원리와 동일하게 동작한다.
- 복습하면서 쓰자면 find를 통해서 SELECT 쿼리를 DB로 날려서 영속성컨텍스트의 1차 캐싱에 엔티티를 관리해놓으면 그때의 스냅샷과 remove된이후의 엔티티의 변경을 감지하고 쓰기지연 SQL에 DELETE쿼리를 저장해놓았다가 트랜잭션 커밋될때 DELETE쿼리날라가서 데이터 삭제된다. UPDATE에대한 엔티티 변경감지와 동일한 매커니즘이다.

# 결론

- 영속성 컨텍스트의 특징을 통해서 엔티티가 관리되는 방법을 알게됨
- 중요한건 데이터베이스와 어플사이에 영속성 컨텍스트가 존재해서 1차캐싱, 버퍼링등의 다양한 기능이 존재한다는 것이다.
