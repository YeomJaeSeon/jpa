# 플러시

- 영속성 컨텍스트의 변경내용을 DB에 반영

# 플러시 발생 과정

- 변경감지(스냅샷과 엔티티의 변경을 감지함)
- 영속성 컨텍스트 내의 SQL쓰기지연저장소에 해당 변경에 대한 쿼리를 저장해놓음
- 쓰기지연 SQL의 쿼리를 DB로 전송한다.

> 즉 플러쉬는 영속성 컨텍스트와 DB를 동기화 하는 작업임.

# 영속성 컨텍스트를 플러시하는 방법

1. `em.flush()` - 플러쉬를 직접 호출한다.
2. 틀랜잭션 커밋 - 플러시를 자동으로 호출한다.
3. jpql 쿼리실행 - 플러시를 자동으로 호출한다.

```java
            em.persist(new Member(5L, "memberD"));

            System.out.println("=========");

            tx.commit();
```

- 엔티티 저장하는과정이다.
- 영속성컨텍스틀르 플러시(영속성 컨텍스트와 DB동기화)하는 방법중 2번째인 트랜잭션 커밋시 자동으로 플러시가 호출된다.
- 즉 이때, 쓰기지연 SQL저장소의 쿼리인 INSERT가 DB로 전달되어 영속성컨텍스트-DB간의 동기화가 되는것이다.
- 당연히 INSERT쿼리는 트랜잭션 커밋될때 나가게된다.
- 만약 직접 플러시를 호출하면?

```java
            em.persist(new Member(5L, "memberD"));
            em.flush();
            System.out.println("=========");

            tx.commit();
```

- 커밋되기전에 쿼리가 먼저 날라간다. (INSERT)

> 즉, 플러시는 영속성 컨텍스트와 DataBase를 같게 만드는 작업이다. (영속성 컨텍스트의 변경내용을 DB에 적용함으로써)

# 플러시 주의점

- 영속성 컨텍스트를 비우지않는다. 단순히 영속성컨텍스트의 변경 내용을 DB에 쿼리를 날려 반영할뿐이다. 영속성컨텍스트를 비우는게아닌 영속성 컨택스트 **내의 쓰기지연 SQL저장소에 저장된 SQL**을 DB로 날리고 비워지는 것이다.

- 즉, 영속성 컨텍스트의 변경내용을 DB에 동기화한다.

- 트랜잭션이라는 작업단위(논리적인 여러 쿼리들의 묶음)가 중요한데 트랜잭션 커밋(DB에 쿼리묶음인 트랜잭션 반영)되기 직전에만 플러시를 통해서 영속성컨텍스트와 DB를 동기화하면된다.

> 플러시는 영속성컨텍스트의 변경사항을 DB에 적용해 동기화를 한다.
