# 부모 엔티티와 연관된 자식엔티티

- 부모 엔티티와 연관된 자식엔티티에 대해서 영속화라던가 삭제라던가에 대한 작업은 두 엔티티 모두에 적용을 해야한다.-> 당연하다. 영속성컨텍스트에 직접 대상할 엔티티를 지정해야한다.
- 그런데 개발자입장에선 귀찮다. 부모 엔티티에 대한 영속화나, 삭제 등에 대한 작업을 하면 자식엔티티도 자연스레 적용되면 편하지않을까? 라는생각에서 시작되었다.
- 바로 영속성 전이이다. cascasde(CSS의 그 CasCade이다.)

# 부모 엔티티에서 자식엔티티의 참조를 가지고있을때,

```java
//in Parent 엔티티
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<Child> childList = new ArrayList<>();
```

- 부모엔티티에서 자식엔티티의 참조를 가지고있다.
- 이때 casecade속성값에 영속성전이의 능력을 부여할수있다.
- 이렇게 부여하면 어떤식으로 되는데?

```java
            Child child1 = new Child();
            Child child2 = new Child();

            Parent parent = new Parent();
            parent.addChild(child1);
            parent.addChild(child2);

            em.persist(parent);
```

- 영속성 전이 속성을 사용하지않으면 당연히 부모 엔티티만 영속화된다. (영속성 컨텍스트에 의해 관리된다.)
- 그러므로 플러쉬될때, DB로 SQL나간다.
- 그러나 영속성전이 옵션을 이용하면 자연스레 부모 엔티티와 연관된 자식엔티티도 영속화가되어 결국 DB로 insert SQL이 나가게된다.
- 즉, 편하다. em.persist 를 중복해서 쓸필요가없으니..
- 그만큼 주의할점이따른다.

# 영속성 전이 사용 주의

1. 라이프 사이클이 동일해야한다.

- 부모와 연관된 자식 엔티티는 부모엔티티와 라이프사이클이 동일해야한다. 그래야 복잡한 문제를 일으키지않는다.

2. 자식엔티티는 부모엔티티의 개인 소유여야한다.

- 이말이뭐냐면 다른 엔티티들이 자식엔티티와 관계가 있으면 안된다는 의미이다. 부모엔티티말고 다른 엔티티가 자식엔티티와 관계가있으면 부모엔티티를 영속화하면 자식에티티가 생기고 갑자기 다른엔티티에서도 생기게되닌까 복잡한 문제를 초래한다.

> 위 두가지 사항에대해서 생각하면서 주의하며 사용하자.

## 참고

- 참고로 영속성전이 옵션을 ALL, PERSIST, REMOVE ..등으로 줄수있다.
- 부모 엔티티와 관계가 있다는말은 부모엔티티에서 자식을 참조하는 컬렉션이 존재한다는 의미이다. 컬렉션이 아니여도 된다 `@OneToOne`같은 경우도됨.
- 즉, 부모와 객체에서의 관계(참조)가 존재해야한다.

# 고아객체

- 부모와의 관계가 끊기면 자식 엔티티는 삭제된다.
- 슬픈 얘기지만 그러한 기능이존재한다.
- 즉, 부모엔티티가 참조하는 변수를 삭제하면 자식엔티티를 직접적으로 `em.remove`를사용하지않아도 삭제된다는의미이다.
