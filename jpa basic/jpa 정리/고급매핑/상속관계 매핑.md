# 슈퍼타입 서브타입관계

- 관계형 DB는상속관계가없다.
- 객체의 상속관계와 매우 비슷한 슈퍼타입 서브타입 관계가 존재한다.
- 객체의 상속관계와 슈퍼타입 서브타입을 매핑해서 jpa를 이용하는 방법을 알아보자.

# 슈퍼타입 서브타입 물리설계

- 슈퍼타입 서브타입의 논리설계를 물리적설계로 실체화하는 방법은 세가지가있따.

1. 조인전략

- 공통의 필드를 슈퍼타입 테이블에두고 서브타입 테이블에서 자신의 필드를 가지고있다.
- 구분을 위해서 필요하다면 Dtype을 이용할수있다.(필수는 아님)

2. 단일 테이블전략

- 하나의 테이블에 슈퍼타입, 서브타입테이블의 필드를 몽땅 다 집어넣는다.
- 구분을 위해서 DType을 이용한다.

3. 구현 클래스마다 테이블전략

- 슈퍼타입 테이블이 존재하지않고 구현 클래스마다 각각의 테이블들이 존재한다.
- 공통의 필드를 묶는 부분이없어 데이터 무결성을 지키지못한다.
- 각 테이블간의 통합되는 부분이없어서 장기적으로 봤을때, 수정에 있어서 불리하다.(변경에 불리)

# 슈퍼타입, 서브타입과 매핑하도록도와주는 jpa에서 제공하는 애너테이션들

- `@Inheritance` default는 단일 테이블전략이다. 속성을 통해서, 조인전략, 구현클래스마다 테이블 전략을 적용할수있다.
- `@DiscriminatorColumn(name="HELLO")`를 통해 DTYPE 필드의 이름을 지정할수있따. default는 DTYPE이다.(각 서브타입을 구분할 DTYPE의 이름이 DTYPE)
- `@DiscriminatorValue("xXx")`를 통해서 DTYPE필드에 지정될 값을 정할수있다. 기본값은 엔티티이름. (MOVIE -> M)으로 DTYPE에 묶일 이름 변경가능

# 상속관계 매핑 - 조인 전략

- 슈퍼타입 서브타입 조인전략과 상속관계를 매핑하는 방법은 `@Inheritance(strategy = InheritanceType.JOINED)` 애너테이션을 이용한다.
- 슈퍼타입 서브타입은 공통의 필드를 가지고있는 슈퍼타입과 개별적인 필드를 가진 서브타입으로 구분된다. 각 테이블간의 정규화가 잘 되었기에 저장공간이 효율적이다.
- 또, 공통의 필드를 나타내는 슈퍼타입 테이블이 존재하기에 참조 무결성도 좋다.(다른 테이블과의 참조시 슈퍼타입 테이블과 참조가 쉬움)

- 그러나 데이터 등록시, 슈퍼타입테이블, 서브타입 테이블 둘다에 insert가 나가야한다. 그리고 조회도 무조건 조인을 해야한다.
- 즉, **복잡하다**

# 상속관계 매핑 - 단일 테이블 전략

- `@Inheritance`에너테이션의 default이므로 다른 설정 불필요.
- 한테이블에 다 때려박기떄문에 한 테이블 내 구분이 필요 -> DTYPE이 필수임(조인 전략은 DTYPE을 추가할수도있지만, 단일 테이블전략은 필수임)
- 너무 간단하다, 한테이블에 데이터가 다존재하기에 데이터 등록, 조회등등이 간단하다.
- 조인도 필요없어서 성능이 빠르다
- 그러나.. 꼭 필요한 데이터 제외하곤 전부다 null을 허용해야한다. 그리고 모든 데이터를 한 테이블에 저장하므로 테이블이 너무 커질수있다. 너무커지면 또 성능에 좋지못하다.

# 상속관계 매핑 - 구현클래스마다 테이블 전략

- 안좋다.
- 왜? 조인전략과, 단일테이블 전략과는 다르게 각 서브타입 테이블마다 통합되는 부분이 없다. 연결되는 부분이 없다. -> 최초에 설정한 부분이 변경이 일어나면 너무 복잡해진다.
- 사용하지말자

# 결론

- 조인 전략을 기본적으로 사용하되, 좀 간단하고, 변경가능성도없고, 데이터도 적으면 그냥 단일테이블 전략 을이용하자. 단일테이블 전략이 더 쉽기에.!

- 관계형 DB는 객체처럼 상속관계를 못나타내지만 슈퍼타입 서브타입 관계가 존재한다. 슈퍼타입 서브타입을 나타내는 세가지 전략중 현재 상황에 맞게 적절한 전략을 사용해서 객체 상속관계와 매핑하여 jpa를 이용하자.(조인 전략과 단일 테이블전략의 차이를 이해해서 필요에 따라서 적절하게 적용하자.)
